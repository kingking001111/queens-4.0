<!doctype html>
<html lang="zh-Hant">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Queens ç„¡é™ç”Ÿé¡Œï¼ˆLinkedIn é¡ä¼¼ç‰ˆï¼‰</title>
  <style>
    :root { --cell: 54px; }
    body { font-family: system-ui, -apple-system, "Segoe UI", Arial; margin: 18px; }
    h1 { margin: 0 0 8px; font-size: 20px; }
    .sub { margin: 0 0 14px; font-size: 13px; line-height: 1.55; color: #222; }
    .row { display: flex; gap: 10px; flex-wrap: wrap; align-items: center; margin: 10px 0; }
    button, select {
      padding: 8px 12px; border: 1px solid #111; background:#fff; border-radius: 10px;
      cursor:pointer; font-weight: 650;
    }
    button:hover { background:#f6f6f6; }
    .badge { display:inline-block; padding: 6px 10px; border: 1px solid #111; border-radius: 999px; }
    .small { font-size: 13px; line-height: 1.55; color:#222; }
    .mono { font-family: ui-monospace, Menlo, Consolas, monospace; }
    .ok { color:#1b5e20; font-weight: 800; }
    .bad { color:#b71c1c; font-weight: 800; }

    .wrap { display: grid; gap: 14px; grid-template-columns: max-content 1fr; align-items: start; }

    .board {
      display:grid;
      border: 2px solid #111;
      width:max-content;
      user-select:none;
    }
    .cell{
      width: var(--cell); height: var(--cell);
      display:grid; place-items:center;
      font-size: 24px;
      cursor:pointer;
      position: relative;
      border: 1px solid rgba(0,0,0,.18);
      background: #fafafa;
    }
    .cell.conflict { outline: 3px solid #e53935; outline-offset: -3px; }
    .cell .tag{
      position:absolute; left:6px; top:6px;
      font-size: 11px; opacity: .55;
    }
    /* Grey cells are playable for notes (X/ğŸ‘‘), but not valid for final ğŸ‘‘ */
    .cell.blocked{
      background: #d6d6d6 !important;
      opacity: .95;
    }
    .cell.blocked .tag{ display:none; }

    .legend { display:flex; flex-wrap:wrap; gap:6px; margin-top:10px; max-width:520px; }
    .chip { display:flex; gap:6px; align-items:center; border:1px solid #111; border-radius:999px; padding:4px 8px; font-size:12px; }
    .sw { width:14px; height:14px; border-radius:4px; border:1px solid rgba(0,0,0,.25); }

    .card {
      border: 1px solid rgba(0,0,0,.25);
      border-radius: 14px;
      padding: 12px;
      max-width: 560px;
      background: #fff;
    }
  </style>
</head>
<body>
  <h1>Queens ç„¡é™ç”Ÿé¡Œï¼ˆLinkedIn é¡ä¼¼è¦å‰‡ï¼‰</h1>
  <p class="sub">
    ç›®æ¨™ï¼šåœ¨<strong>æ¯è¡Œã€æ¯åˆ—ã€æ¯å€‹è‰²å¡Šå€åŸŸ</strong>ä¸­æ°å¥½æœ‰ä¸€å€‹ ğŸ‘‘ã€‚<br/>
    æ“ä½œï¼š<strong>é»ä¸€ä¸‹æ”¾ X</strong>ï¼Œ<strong>é»å…©ä¸‹æ”¾ ğŸ‘‘</strong>ï¼Œ<strong>å†é»ä¸€æ¬¡æ¸…ç©º</strong>ã€‚ç°è‰²æ ¼ä¹Ÿå¯æ”¾ Xï¼ğŸ‘‘ åšæ¨ç†ã€‚<br/>
    éé—œåˆ¤å®šï¼šåªæœ‰<strong>æ”¾åœ¨æœ‰è‰²å€å¡Šå…§</strong>çš„ ğŸ‘‘ æœƒè¢«èªå¯ï¼›ä¸”å…©å€‹ ğŸ‘‘ ä¸èƒ½ç›¸é„°ï¼ˆä¸Šä¸‹å·¦å³ï¼‹æ–œè§’éƒ½ä¸è¡Œï¼‰ã€‚
  </p>

  <div class="row">
    <label class="small">å°ºå¯¸ï¼š</label>
    <select id="size">
      <option value="6">6Ã—6</option>
      <option value="7">7Ã—7</option>
      <option value="8" selected>8Ã—8ï¼ˆæœ€åƒ LinkedInï¼‰</option>
      <option value="9">9Ã—9</option>
      <option value="10">10Ã—10</option>
    </select>

    <button id="new">æ–°é¡Œç›®</button>
    <button id="clear">æ¸…ç©ºæ¨™è¨˜</button>
    <button id="check">æª¢æŸ¥</button>
    <button id="solve">é¡¯ç¤ºè§£</button>
  </div>

  <div class="row">
    <span class="badge">ğŸ‘‘ï¼š<span id="qCount">0</span>/<span id="n">8</span></span>
    <span class="badge">ç‹€æ…‹ï¼š<span id="status" class="mono">-</span></span>
    <span class="badge">Seedï¼š<span id="seed" class="mono">-</span></span>
  </div>

  <div class="wrap">
    <div>
      <div id="board" class="board" aria-label="board"></div>
      <div class="legend" id="legend"></div>
    </div>

    <div class="card small">
      <div class="mono">ğŸ‘‘åº§æ¨™ï¼š<span id="pos"></span></div>
      <div style="margin-top:10px;">
        ç°è‰²æ ¼çš„ ğŸ‘‘ åªç•¶ä½œã€Œæ¨ç†ç­†è¨˜ã€ï¼Œä¸æœƒè¢«éé—œåˆ¤å®šæ¥å—ï¼ˆæœƒæ¨™ç´…æé†’ï¼‰ã€‚<br/>
        X æ˜¯ç”¨ä¾†æ¨™è¨˜ã€Œé€™æ ¼ä¸å¯èƒ½æ”¾ ğŸ‘‘ã€ã€‚
      </div>
    </div>
  </div>

<script>
(() => {
  // ---------- Random ----------
  function mulberry32(a) {
    return function() {
      let t = a += 0x6D2B79F5;
      t = Math.imul(t ^ (t >>> 15), t | 1);
      t ^= t + Math.imul(t ^ (t >>> 7), t | 61);
      return ((t ^ (t >>> 14)) >>> 0) / 4294967296;
    };
  }
  function randInt(rng, lo, hi) { return lo + Math.floor(rng() * (hi - lo)); }
  function shuffle(rng, arr) {
    for (let i = arr.length - 1; i > 0; i--) {
      const j = randInt(rng, 0, i + 1);
      [arr[i], arr[j]] = [arr[j], arr[i]];
    }
    return arr;
  }
  function isAdj(r1,c1,r2,c2){ return Math.abs(r1-r2) <= 1 && Math.abs(c1-c2) <= 1; }

  // ---------- DOM ----------
  const boardEl = document.getElementById('board');
  const legendEl = document.getElementById('legend');
  const sizeSel = document.getElementById('size');
  const newBtn = document.getElementById('new');
  const clearBtn = document.getElementById('clear');
  const checkBtn = document.getElementById('check');
  const solveBtn = document.getElementById('solve');

  const qCountEl = document.getElementById('qCount');
  const nEl = document.getElementById('n');
  const statusEl = document.getElementById('status');
  const seedEl = document.getElementById('seed');
  const posEl = document.getElementById('pos');

  // ---------- State ----------
  // cellState: 0 empty, 1 X, 2 Queen
  let N = 8;
  let seed = 0;
  let rng = Math.random;

  // regionGrid: -1 = grey (not a region), 0..N-1 playable region id
  let regionGrid = [];
  let regionColors = [];
  let solution = []; // [r] -> c (queen positions, always inside colored region)
  let cells = [];
  let cellState = [];

  function initCellState(){
    cellState = Array.from({length:N}, ()=>Array(N).fill(0));
  }

  function countQueens(){
    let cnt = 0;
    for (let r=0;r<N;r++) for (let c=0;c<N;c++) if (cellState[r][c] === 2) cnt++;
    return cnt;
  }

  function queenPositions(){
    const out = [];
    for (let r=0;r<N;r++){
      for (let c=0;c<N;c++){
        if (cellState[r][c] === 2) out.push([r,c]);
      }
    }
    return out;
  }

  // ---------- Generate a valid solution first (row unique, col unique, no adjacency) ----------
  function genBaseSolutionOnlyNoAdj(){
    const state = Array(N).fill(-1);
    const usedCols = new Set();

    function backtrack(row){
      if (row === N) return true;
      const cols = shuffle(rng, Array.from({length:N}, (_,i)=>i));
      for (const col of cols){
        if (usedCols.has(col)) continue;
        let ok = true;
        for (let r=0;r<row;r++){
          const c = state[r];
          if (isAdj(r,c,row,col)) { ok = false; break; }
        }
        if (!ok) continue;
        state[row] = col;
        usedCols.add(col);
        if (backtrack(row+1)) return true;
        usedCols.delete(col);
        state[row] = -1;
      }
      return false;
    }

    for (let tries=0; tries<260; tries++){
      usedCols.clear();
      state.fill(-1);
      if (backtrack(0)) return state.slice();
    }
    throw new Error("é€™å€‹å°ºå¯¸ç”Ÿæˆå¤ªåˆé‘½ï¼ˆé‡è©¦å¤±æ•—ï¼‰ã€‚è«‹æ›å°ä¸€é» N æˆ–å†æŒ‰ä¸€æ¬¡æ–°é¡Œç›®ã€‚");
  }

  // ---------- Sparse colored regions (size 4 or 5 each), others grey ----------
  function buildSparseRegionsFromSolution(sol){
    const grid = Array.from({length:N}, ()=>Array(N).fill(-1));

    // target sizes: 4 or 5 each
    const k = randInt(rng, 0, N + 1);
    const sizes = Array(N).fill(4);
    const ids = shuffle(rng, Array.from({length:N}, (_,i)=>i));
    for (let i=0;i<k;i++) sizes[ids[i]] = 5;

    // seed each region at its solution queen cell
    for (let reg=0; reg<N; reg++){
      const r = reg;
      const c = sol[r];
      grid[r][c] = reg;
    }

    const fronts = Array.from({length:N}, ()=>[]);
    function addNeighbors(reg, r, c){
      const dirs = [[1,0],[-1,0],[0,1],[0,-1]];
      for (const [dr,dc] of dirs){
        const nr=r+dr, nc=c+dc;
        if (nr<0||nr>=N||nc<0||nc>=N) continue;
        if (grid[nr][nc] !== -1) continue;
        fronts[reg].push([nr,nc]);
      }
    }

    for (let reg=0; reg<N; reg++){
      addNeighbors(reg, reg, sol[reg]);
    }

    const cur = Array(N).fill(1);

    let guard = 0;
    while (true){
      guard++;
      if (guard > 20000) return null;

      let done = true;
      for (let reg=0; reg<N; reg++){
        if (cur[reg] < sizes[reg]) { done = false; break; }
      }
      if (done) break;

      const candidates = [];
      for (let reg=0; reg<N; reg++){
        if (cur[reg] < sizes[reg] && fronts[reg].length > 0) candidates.push(reg);
      }
      if (candidates.length === 0) return null;

      candidates.sort((a,b)=> (sizes[b]-cur[b]) - (sizes[a]-cur[a]));
      const pickBand = Math.min(candidates.length, 3);
      const reg = candidates[randInt(rng, 0, pickBand)];

      let chosen = null;
      for (let t=0; t<12 && fronts[reg].length; t++){
        const idx = randInt(rng, 0, fronts[reg].length);
        const [r,c] = fronts[reg][idx];
        fronts[reg][idx] = fronts[reg][fronts[reg].length-1];
        fronts[reg].pop();
        if (grid[r][c] === -1){ chosen = [r,c]; break; }
      }
      if (!chosen) continue;

      const [rr,cc] = chosen;
      grid[rr][cc] = reg;
      cur[reg] += 1;
      addNeighbors(reg, rr, cc);
    }

    return grid;
  }

  function buildColors(){
    regionColors = Array.from({length:N}, (_,i)=> {
      const hue = (((i * 360) / N) + (seed % 97)) % 360;
      return `hsl(${hue} 70% 88%)`;
    });
  }

  // ---------- UI build ----------
  function buildBoard(){
    boardEl.innerHTML = '';
    legendEl.innerHTML = '';

    boardEl.style.gridTemplateColumns = `repeat(${N}, var(--cell))`;
    boardEl.style.gridTemplateRows = `repeat(${N}, var(--cell))`;

    cells = Array.from({length:N}, ()=>Array(N).fill(null));

    for (let r=0;r<N;r++){
      for (let c=0;c<N;c++){
        const d = document.createElement('div');
        d.className = 'cell';
        d.dataset.r = r;
        d.dataset.c = c;

        const reg = regionGrid[r][c];
        if (reg === -1){
          d.classList.add('blocked');
        } else {
          d.style.background = regionColors[reg];
          const tag = document.createElement('div');
          tag.className = 'tag';
          tag.textContent = String.fromCharCode(65 + (reg % 26));
          d.appendChild(tag);
        }

        d.addEventListener('click', () => cycleCell(r,c));
        boardEl.appendChild(d);
        cells[r][c] = d;
      }
    }

    for (let reg=0; reg<N; reg++){
      const chip = document.createElement('div');
      chip.className = 'chip';
      const sw = document.createElement('div');
      sw.className = 'sw';
      sw.style.background = regionColors[reg];
      const t = document.createElement('div');
      t.textContent = `å€åŸŸ ${String.fromCharCode(65 + (reg % 26))}`;
      chip.appendChild(sw); chip.appendChild(t);
      legendEl.appendChild(chip);
    }
  }

  // Cycle: empty -> X -> Queen -> empty (works on both colored and grey)
  function cycleCell(r,c){
    const v = cellState[r][c];
    cellState[r][c] = (v + 1) % 3;
    updateUI();
  }

  function computeConflicts(){
    const queensPos = queenPositions();
    const bad = new Set();

    // Count queens per row/col (ALL queens, including grey)
    const rowCount = Array(N).fill(0);
    const colCount = Array(N).fill(0);

    // Count queens per region (ONLY colored regions)
    const regCount = Array(N).fill(0);

    for (const [r,c] of queensPos){
      rowCount[r]++; colCount[c]++;
      const reg = regionGrid[r][c];
      if (reg >= 0) regCount[reg]++;
    }

    // Mark queens that violate row/col uniqueness
    for (const [r,c] of queensPos){
      const reg = regionGrid[r][c];

      // Queen placed on grey is always invalid for final -> mark conflict
      if (reg === -1) bad.add(`${r},${c}`);

      if (rowCount[r] > 1 || colCount[c] > 1) bad.add(`${r},${c}`);
      if (reg >= 0 && regCount[reg] > 1) bad.add(`${r},${c}`);
    }

    // Adjacency conflicts (ALL queens anywhere)
    for (let i=0;i<queensPos.length;i++){
      for (let j=i+1;j<queensPos.length;j++){
        const [r1,c1]=queensPos[i], [r2,c2]=queensPos[j];
        if (isAdj(r1,c1,r2,c2)){
          bad.add(`${r1},${c1}`);
          bad.add(`${r2},${c2}`);
        }
      }
    }

    return bad;
  }

  function updateUI(){
    for (let r=0;r<N;r++){
      for (let c=0;c<N;c++){
        const d = cells[r][c];
        d.classList.remove('conflict');
        d.childNodes.forEach(node => {
          if (node.nodeType === Node.TEXT_NODE) d.removeChild(node);
        });
      }
    }

    for (let r=0;r<N;r++){
      for (let c=0;c<N;c++){
        if (cellState[r][c] === 1) cells[r][c].appendChild(document.createTextNode('X'));
        if (cellState[r][c] === 2) cells[r][c].appendChild(document.createTextNode('ğŸ‘‘'));
      }
    }

    const qCnt = countQueens();
    qCountEl.textContent = String(qCnt);

    const bad = computeConflicts();
    bad.forEach(k=>{
      const [r,c]=k.split(',').map(Number);
      cells[r][c].classList.add('conflict');
    });

    const list = queenPositions().map(([r,c])=>{
      const col = String.fromCharCode('A'.charCodeAt(0)+c);
      return `${col}${r+1}`;
    }).join(', ');
    posEl.textContent = list;

    if (qCnt === 0) statusEl.textContent = '-';
    else if (bad.size > 0) statusEl.innerHTML = `<span class="bad">æœ‰è¡çªï¼ˆå«ç°è‰²ğŸ‘‘ä¹Ÿæœƒæ¨™ç´…ï¼‰</span>`;
    else statusEl.innerHTML = `<span class="ok">OKï¼ˆæš«ç„¡è¡çªï¼‰</span>`;
  }

  // ---------- Controls ----------
  function clearMarks(){
    for (let r=0;r<N;r++) for (let c=0;c<N;c++) cellState[r][c] = 0;
    updateUI();
    statusEl.textContent = '-';
  }

  function checkWin(){
    const queensPos = queenPositions();
    const bad = computeConflicts();

    // Need exactly N queens total
    if (queensPos.length !== N){
      statusEl.innerHTML = `<span class="bad">ğŸ‘‘æ•¸é‡ä¸å°ï¼ˆ${queensPos.length}/${N}ï¼‰</span>`;
      return;
    }

    // All queens must be in colored regions
    for (const [r,c] of queensPos){
      if (regionGrid[r][c] === -1){
        statusEl.innerHTML = `<span class="bad">ç°è‰²æ ¼ä¸Šçš„ ğŸ‘‘ ä¸ç®—éé—œï¼ˆè«‹ç§»åˆ°è‰²å¡Šå…§ï¼‰</span>`;
        return;
      }
    }

    if (bad.size > 0){
      statusEl.innerHTML = `<span class="bad">æœ‰è¡çªï¼Œç´…æ¡†è™•è¦èª¿æ•´</span>`;
      return;
    }

    // Ensure exactly one queen per row/col/region (now queens are all colored)
    const rowCount = Array(N).fill(0);
    const colCount = Array(N).fill(0);
    const regCount = Array(N).fill(0);

    for (const [r,c] of queensPos){
      rowCount[r]++; colCount[c]++;
      const reg = regionGrid[r][c];
      regCount[reg]++;
    }

    for (let i=0;i<N;i++){
      if (rowCount[i] !== 1) { statusEl.innerHTML = `<span class="bad">ç¬¬ ${i+1} è¡Œ ğŸ‘‘ ä¸æ˜¯ 1 å€‹</span>`; return; }
      if (colCount[i] !== 1) { statusEl.innerHTML = `<span class="bad">ç¬¬ ${i+1} åˆ— ğŸ‘‘ ä¸æ˜¯ 1 å€‹</span>`; return; }
      if (regCount[i] !== 1) { statusEl.innerHTML = `<span class="bad">å€åŸŸ ${String.fromCharCode(65+(i%26))} ğŸ‘‘ ä¸æ˜¯ 1 å€‹</span>`; return; }
    }

    statusEl.innerHTML = `<span class="ok">æ­å–œå®Œæˆï¼</span>`;
  }

  function showSolution(){
    clearMarks();
    for (let r=0;r<N;r++){
      const c = solution[r];
      cellState[r][c] = 2;
    }
    updateUI();
    statusEl.innerHTML = `<span class="ok">å·²é¡¯ç¤ºè§£</span>`;
  }

  // ---------- Puzzle generation ----------
  function genPuzzle(){
    seed = (Date.now() ^ (Math.random()*1e9)) >>> 0;
    rng = mulberry32(seed);
    seedEl.textContent = String(seed);

    N = parseInt(sizeSel.value, 10);
    nEl.textContent = String(N);

    for (let attempt=0; attempt<180; attempt++){
      const sol = genBaseSolutionOnlyNoAdj();
      const reg = buildSparseRegionsFromSolution(sol);
      if (!reg) continue;

      solution = sol;
      regionGrid = reg;
      buildColors();
      initCellState();
      buildBoard();
      updateUI();
      statusEl.textContent = '-';
      return;
    }
    throw new Error("ç”Ÿæˆå¤±æ•—ï¼šè«‹å†æŒ‰ä¸€æ¬¡ã€Œæ–°é¡Œç›®ã€æˆ–æ”¹è®Šå°ºå¯¸ã€‚");
  }

  // ---------- Events ----------
  newBtn.addEventListener('click', () => { try { genPuzzle(); } catch(e){ alert(e.message || String(e)); } });
  clearBtn.addEventListener('click', clearMarks);
  checkBtn.addEventListener('click', checkWin);
  solveBtn.addEventListener('click', showSolution);
  sizeSel.addEventListener('change', () => { try { genPuzzle(); } catch(e){ alert(e.message || String(e)); } });

  // Initial
  genPuzzle();
})();
</script>
    // Count number of solutions for THIS puzzle (colored cells only).
  // Stops early once it finds 2 solutions.
  function countSolutions(maxSolutions = 2) {
    let count = 0;
    const colUsed = Array(N).fill(false);
    const regUsed = Array(N).fill(false);
    const placedCol = Array(N).fill(-1);

    function dfs(r) {
      if (count >= maxSolutions) return;
      if (r === N) { count++; return; }

      for (let c = 0; c < N; c++) {
        const reg = regionGrid[r][c];
        if (reg === -1) continue;         // only colored cells are allowed
        if (colUsed[c]) continue;
        if (regUsed[reg]) continue;

        // adjacency: because we place exactly 1 per row, only row r-1 can be adjacent
        if (r > 0) {
          const pc = placedCol[r - 1];
          if (pc !== -1 && Math.abs(pc - c) <= 1) continue; // includes diagonal and vertical adjacency
        }

        colUsed[c] = true;
        regUsed[reg] = true;
        placedCol[r] = c;

        dfs(r + 1);

        colUsed[c] = false;
        regUsed[reg] = false;
        placedCol[r] = -1;
      }
    }

    dfs(0);
    return count;
  }

</body>
</html>
